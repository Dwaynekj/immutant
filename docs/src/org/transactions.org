#+TITLE:     Distributed Transactions (XA)

* Introduction
  
  Immutant encapsulates the distributed transaction support provided
  by JBoss AS7 within the [[./apidoc/immutant.xa-api.html][immutant.xa]] namespace.

  A *distributed* transaction is one in which multiple types of
  resources may participate. The most common example of a
  transactional resource is a relational database, but Immutant
  /caches/ (backed by [[http://www.infinispan.org][Infinispan]]) and /message handlers/ (backed by
  [[http://www.jboss.org/hornetq/][HornetQ]]) are also transactional. Technically speaking, they provide
  implementations of the [[http://en.wikipedia.org/wiki/X/Open_XA][XA protocol]], and any back-end data store that
  does so may participate in an Immutant transaction.

  This allows your application to say, tie the success of a SQL
  database update or the storage of an entry on a replicated data grid
  to the delivery of a message to a remote queue, i.e. the message is
  only sent if the database and data grid update successfully. If any
  single component of an XA transaction fails, all of them rollback.

  The =immutant.xa= namespace contains only two functions:
  
  | =datasource=  | Creates a valid XA DataSource for the most common SQL databases           |
  | =transaction= | A macro that wraps its body in a transaction unless one is already active |

  More fine-grained transactional control is available through the
  [[./apidoc/immutant.xa-api.html#immutant.xa.transaction][immutant.xa.transaction]] namespace, described below.

* Creating XA DataSources

  In order for your database to participate in an XA transaction, an
  XA DataSource must be created for it. As an Immutant user, you have
  two options: either 1) call =immutant.xa/datasource= from your
  application or 2) use the JBoss AS7 configuration facilities. The
  former is simple and recommended for most deployments, but the
  latter facilitates management when you have multiple applications
  sharing the same DataSource in a clustered environment.

** Using an Immutant DataSource with =clojure.java.jdbc=

   The spec you pass to =clojure.java.jdbc/with-connection= will
   either set the =:datasource= key to the value returned by
   =immutant.xa/datasource= or the =:name= key to the JNDI name from
   the JBoss configuration.

   It's just that simple. And any library based on =clojure.java.jdbc=
   should work with that spec.

*** A DataSource created using =immutant.xa/datasource=

    To create your own DataSource, you must make the appropriate JDBC
    driver available. This is easily done with a [[http://leiningen.org/][Leiningen]] project in
    =project.clj=. All of the following drivers are known to work:

    #+begin_src clojure
      (defproject foo "1.0.0-SNAPSHOT"
        :dependencies [[com.h2database/h2 "1.3.160"]              ; H2
                       [org.clojars.gukjoon/ojdbc "1.4"]          ; Oracle
                       [org.clojars.kjw/mysql-connector "5.1.11"] ; MySQL
                       [postgresql "9.0-801.jdbc4"]               ; Postgres
                       [net.sourceforge.jtds/jtds "1.2.4"]        ; MS SQL Server
                       [java.jdbc "0.2.2"]])
    #+end_src

    Here's an example creating a datasource for an in-memory H2 database:
    
    #+begin_src clojure
      (defonce ds (immutant.xa/datasource "foo" {:adapter "h2" :database "mem:foo"}))
      (jdbc/with-connection {:datasource ds}
        (jdbc/create-table :things [:name "varchar(50)"]))
    #+end_src

    Here's an example creating an Oracle datasource for an Amazon RDS
    instance:

    #+begin_src clojure
      ;;; rds-create-db-instance myinstance -s 10 -c db.m1.small -e oracle-se -u myuser -p mypassword --db-name mydb
      (defonce ds (ixa/datasource "foo" {:adapter "oracle"
                                         :host "myinstance.xxxxxxxxxxxx.us-east-1.rds.amazonaws.com"
                                         :username "myuser"
                                         :password "mypassword"
                                         :database "mydb"}))
      (jdbc/with-connection {:datasource ds} ...)
    #+end_src

*** An AS7-configured DataSource

    Once you've [[https://docs.jboss.org/author/display/AS71/DataSource%2Bconfiguration][configured your XA DataSource in AS7]], you simply refer
    to its JNDI name:

    #+begin_src clojure
      (jdbc/with-connection {:name "java:jboss/datasources/ExampleXADS"}
        (jdbc/create-table :things [:name "varchar(50)"]))
    #+end_src


* Defining Transactions

** Transaction Scope

   When transactional components interact, the state of a transaction
   when a particular function is invoked isn't always easy to predict,
   e.g. can a function that requires a transaction assume one has been
   started prior to its invocation? In JEE container-managed
   persistence, a developer answers these questions using the
   @Transaction annotation.

   But annotations are gross, right? :)

   So instead, =immutant.xa.transaction= provides analogs to the
   @Transaction scope attribute in the form of Clojure macros.

